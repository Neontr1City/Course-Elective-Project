# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'final.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import os
from config import UI_CONFIG
import pandas as pd
from datetime import datetime
from course_scheduler import CourseScheduler, create_course_from_dict

# 用户数据将在运行时动态获取，避免循环导入
user_data = None

def get_user_data():
    """动态获取用户数据，避免循环导入"""
    global user_data
    if user_data is None:
        try:
            import main_enhanced
            user_data = main_enhanced.user_data
            print(f"Final.py - 成功导入用户数据: {dict(user_data)}")
        except (ImportError, AttributeError) as e:
            print(f"Final.py - 导入用户数据失败: {e}，使用默认数据")
            user_data = {
                "compulsory_courses": [],
                "optional_compulsory_courses": [],
                "general_courses": [],
                "total_credits": 0,
                "age": "未知",
                "major": "未知"
            }
    return user_data

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(900, 700)
        
        # 应用统一样式
        Dialog.setStyleSheet(UI_CONFIG['component_styles']['dialog'])
        
        # 主布局
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        
        # 标题
        self.title_label = QtWidgets.QLabel(Dialog)
        self.title_label.setGeometry(QtCore.QRect(250, 20, 400, 50))
        self.title_label.setObjectName("title_label")
        self.title_label.setAlignment(QtCore.Qt.AlignCenter)
        self.title_label.setText("📅 最终课程表")
        self.title_label.setStyleSheet("""
            QLabel {
                font-family: '楷体';
                font-size: 24px;
                font-weight: bold;
                color: #1A237E;
                background-color: #ffffff;
                border: 2px solid #3F51B5;
                border-radius: 15px;
                padding: 10px;
            }
        """)
        
        # 学生信息区域
        self.info_frame = QtWidgets.QFrame(Dialog)
        self.info_frame.setGeometry(QtCore.QRect(50, 80, 800, 80))
        self.info_frame.setStyleSheet("""
            QFrame {
                background-color: #F5F5F5;
                border: 2px solid #3F51B5;
                border-radius: 10px;
                padding: 10px;
            }
        """)
        
        self.student_info = QtWidgets.QLabel(self.info_frame)
        self.student_info.setGeometry(QtCore.QRect(10, 10, 780, 60))
        self.student_info.setStyleSheet("""
            QLabel {
                font-family: '楷体';
                font-size: 14px;
                font-weight: bold;
                color: #1A237E;
                padding: 5px;
                background: transparent;
            }
        """)
        self.student_info.setWordWrap(True)
        
        # 课表显示区域
        self.schedule_table = QtWidgets.QTableWidget(Dialog)
        self.schedule_table.setGeometry(QtCore.QRect(50, 180, 800, 350))
        self.schedule_table.setObjectName("schedule_table")
        self.schedule_table.setStyleSheet(UI_CONFIG['component_styles']['table'])
        
        # 统计信息区域 - 使用QScrollArea
        self.stats_scroll = QtWidgets.QScrollArea(Dialog)
        self.stats_scroll.setGeometry(QtCore.QRect(50, 550, 400, 100))
        self.stats_scroll.setWidgetResizable(True)
        self.stats_scroll.setStyleSheet("""
            QScrollArea {
                background-color: #ffffff;
                border: 2px solid #2196F3;
                border-radius: 10px;
            }
        """)
        
        self.stats_frame = QtWidgets.QFrame()
        self.stats_frame.setStyleSheet("""
            QFrame {
                background-color: #ffffff;
                padding: 10px;
            }
        """)
        
        self.stats_layout = QtWidgets.QVBoxLayout(self.stats_frame)
        self.stats_label = QtWidgets.QLabel()
        self.stats_label.setWordWrap(True)  # 允许文字换行
        self.stats_label.setStyleSheet(UI_CONFIG['component_styles']['label'])
        self.stats_layout.addWidget(self.stats_label)
        
        self.stats_scroll.setWidget(self.stats_frame)
        
        # 课程列表区域 - 使用QScrollArea
        self.course_scroll = QtWidgets.QScrollArea(Dialog)
        self.course_scroll.setGeometry(QtCore.QRect(470, 550, 380, 100))
        self.course_scroll.setWidgetResizable(True)
        self.course_scroll.setStyleSheet("""
            QScrollArea {
                background-color: #ffffff;
                border: 2px solid #2196F3;
                border-radius: 10px;
            }
        """)
        
        self.course_list = QtWidgets.QTextBrowser()
        self.course_list.setStyleSheet(UI_CONFIG['component_styles']['text_browser'])
        self.course_scroll.setWidget(self.course_list)
        
        # 导出和完成按钮
        button_style = """
            QPushButton {
                background-color: #3F51B5;
                border: none;
                border-radius: 5px;
                padding: 5px 10px;
                font-family: '楷体';
                font-size: 14px;
                font-weight: bold;
                color: white;
            }
            QPushButton:hover {
                background-color: #303F9F;
            }
            QPushButton:pressed {
                background-color: #1A237E;
            }
        """
        
        self.export_button = QtWidgets.QPushButton(Dialog)
        self.export_button.setGeometry(QtCore.QRect(50, 630, 150, 35))
        self.export_button.setObjectName("export_button")
        self.export_button.setText("导出课表")
        self.export_button.setStyleSheet(button_style)
        
        self.finish_button = QtWidgets.QPushButton(Dialog)
        self.finish_button.setGeometry(QtCore.QRect(730, 630, 120, 35))
        self.finish_button.setObjectName("finish_button")
        self.finish_button.setText("完成")
        self.finish_button.setStyleSheet(button_style)
        
        # 背景
        self.background = QtWidgets.QLabel(Dialog)
        self.background.setGeometry(QtCore.QRect(0, 0, 900, 700))
        self.background.setText("")
        base_dir = os.path.dirname(os.path.abspath(__file__))
        background_path = os.path.join(base_dir, "res", "背景.png")
        if os.path.exists(background_path):
            self.background.setPixmap(QtGui.QPixmap(background_path))
        self.background.setObjectName("background")
        
        # 设置z-order
        self.background.raise_()
        self.title_label.raise_()
        self.info_frame.raise_()
        self.schedule_table.raise_()
        self.stats_scroll.raise_()
        self.course_scroll.raise_()
        self.finish_button.raise_()
        self.export_button.raise_()

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "最终课表"))
        self.title_label.setText(_translate("Dialog", "📅 最终课程表"))
        self.finish_button.setText(_translate("Dialog", "完成"))
        self.export_button.setText(_translate("Dialog", "导出课表"))

class FinalDialog(QtWidgets.QDialog, Ui_Dialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowTitle("最终课表")
        
        # 创建课程调度器
        self.scheduler = CourseScheduler()
        
        # 连接信号
        self.finish_button.clicked.connect(self.finish_and_exit)
        self.export_button.clicked.connect(self.export_schedule)
        
        # 生成课表
        self.generate_schedule()

    def finish_and_exit(self):
        """完成选课并退出程序"""
        from PyQt5.QtWidgets import QMessageBox, QApplication
        QMessageBox.information(self, "选课完成", "恭喜您完成选课！祝您学习愉快！")
        self.accept()
        # 退出整个应用程序
        QApplication.quit()

    def generate_schedule(self):
        """生成完整的课程表"""
        try:
            # 获取用户数据
            user_data = get_user_data()
            print("\n=== 课程数据加载情况 ===")
            print(f"必修课数量: {len(user_data.get('compulsory_courses', []))}")
            print(f"选择性必修课数量: {len(user_data.get('optional_compulsory_courses', []))}")
            print(f"通识课数量: {len(user_data.get('general_courses', []))}")
            print("======================\n")
            
            # 更新学生信息
            age = user_data.get('age', '未知')
            major = user_data.get('major', '未知')
            total_credits = user_data.get('total_credits', 0)
            
            # 格式化年级信息
            grade_display = str(age) if age else '未知'
            
            student_info_text = f"学生：{grade_display} {major} | " \
                              f"总学分：{total_credits} | " \
                              f"选课状态：已完成"
            self.student_info.setText(student_info_text)
            
            # 收集所有课程
            all_courses = []
            used_time_slots = set()
            default_times = [
                "周一1-2节", "周一3-4节", "周一5-6节", "周一7-8节",
                "周二1-2节", "周二3-4节", "周二5-6节", "周二7-8节",
                "周三1-2节", "周三3-4节", "周三5-6节", "周三7-8节",
                "周四1-2节", "周四3-4节", "周四5-6节", "周四7-8节",
                "周五1-2节", "周五3-4节", "周五5-6节", "周五7-8节"
            ]
            default_time_idx = 0

            def assign_time(course_dict):
                nonlocal default_time_idx
                # 如果没有上课时间，自动分配
                if not course_dict.get('time') and not course_dict.get('上课时间'):
                    # 找到一个未被占用的时间段
                    while default_time_idx < len(default_times):
                        t = default_times[default_time_idx]
                        default_time_idx += 1
                        if t not in used_time_slots:
                            course_dict['time'] = t
                            used_time_slots.add(t)
                            break
                else:
                    # 标记已用时间
                    t = course_dict.get('time') or course_dict.get('上课时间')
                    used_time_slots.add(t)
                return course_dict

            # 必修课
            compulsory_courses = user_data.get("compulsory_courses", [])
            print("\n=== 必修课加载 ===")
            for course in compulsory_courses:
                course_with_type = course.copy()
                course_with_type['course_type'] = "必修课"
                course_with_type = assign_time(course_with_type)
                course_obj = create_course_from_dict(course_with_type)
                all_courses.append(course_obj)
                self.scheduler.add_selected_course(course_obj)
                print(f"添加必修课: {course_obj.name}")

            # 选择性必修课
            optional_courses = user_data.get("optional_compulsory_courses", [])
            print("\n=== 选择性必修课加载 ===")
            for course in optional_courses:
                course_with_type = course.copy()
                course_with_type['course_type'] = "选择性必修课"
                course_with_type = assign_time(course_with_type)
                course_obj = create_course_from_dict(course_with_type)
                all_courses.append(course_obj)
                self.scheduler.add_selected_course(course_obj)
                print(f"添加选择性必修课: {course_obj.name}")

            # 通识课
            general_courses = user_data.get("general_courses", [])
            print("\n=== 通识课加载 ===")
            for course in general_courses:
                course_with_type = course.copy()
                course_with_type['course_type'] = "通识课"
                course_with_type = assign_time(course_with_type)
                course_obj = create_course_from_dict(course_with_type)
                all_courses.append(course_obj)
                self.scheduler.add_selected_course(course_obj)
                print(f"添加通识课: {course_obj.name}")
            
            print(f"\n总课程数: {len(all_courses)}")
            print(f"调度器中课程数: {len(self.scheduler.selected_courses)}")

            # 创建课表
            self.create_schedule_table()
            
            # 更新统计信息
            self.update_statistics(all_courses)
            
            # 更新课程列表
            self.update_course_list(all_courses)
            
        except Exception as e:
            print(f"生成课表时出错: {e}")
            import traceback
            traceback.print_exc()
            
            # 如果没有课程数据，显示提示信息
            if not any([
                user_data.get("compulsory_courses"),
                user_data.get("optional_compulsory_courses"), 
                user_data.get("general_courses")
            ]):
                self.student_info.setText("暂无课程数据，请重新进行选课")
                # 在课表中显示提示
                item = QtWidgets.QTableWidgetItem("暂无课程数据\n请重新进行选课")
                item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.schedule_table.setRowCount(1)
                self.schedule_table.setColumnCount(1)
                self.schedule_table.setItem(0, 0, item)

    def create_schedule_table(self):
        """创建课程表格"""
        # 设置表格基本属性
        self.schedule_table.clear()
        self.schedule_table.setRowCount(12)
        self.schedule_table.setColumnCount(6)
        
        # 设置表头
        headers = ['时间', '周一', '周二', '周三', '周四', '周五']
        self.schedule_table.setHorizontalHeaderLabels(headers)
        
        # 设置表头样式
        self.schedule_table.horizontalHeader().setStyleSheet("""
            QHeaderView::section {
                background-color: #3F51B5;
                color: white;
                font-family: '楷体';
                font-size: 12px;
                font-weight: bold;
                padding: 4px;
                border: none;
            }
        """)
        
        # 设置时间段
        time_slots = [
            '第1节 (8:00-8:50)', '第2节 (9:00-9:50)',
            '第3节 (10:10-11:00)', '第4节 (11:10-12:00)',
            '第5节 (13:00-13:50)', '第6节 (14:00-14:50)',
            '第7节 (15:10-16:00)', '第8节 (16:10-17:00)',
            '第9节 (17:10-18:00)', '第10节 (18:40-19:30)',
            '第11节 (19:40-20:30)', '第12节 (20:40-21:30)'
        ]
        
        # 设置时间列宽度和样式
        self.schedule_table.setColumnWidth(0, 150)  # 加宽时间列
        
        # 设置时间列
        for i, time_slot in enumerate(time_slots):
            item = QtWidgets.QTableWidgetItem(time_slot)
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            # 为时间列设置特殊字体和样式
            font = QtGui.QFont('Microsoft YaHei', 9)  # 使用雅黑字体，更适合显示数字
            font.setBold(True)
            item.setFont(font)
            item.setBackground(QtGui.QColor('#E8EAF6'))  # 浅色背景
            item.setForeground(QtGui.QColor('#1A237E'))  # 深色文字
            self.schedule_table.setItem(i, 0, item)
        
        # 课程类型对应的颜色 - 使用更柔和的配色
        course_colors = {
            '必修课': '#E3F2FD',  # 浅蓝色
            '选择性必修课': '#F3E5F5',  # 浅紫色
            '通识课': '#E8F5E9'  # 浅绿色
        }
        
        # 获取课程表矩阵
        schedule_matrix = self.scheduler.get_schedule_matrix()
        
        # 填充课程
        for row in range(12):
            for col in range(1, 6):  # 跳过时间列
                course_name = schedule_matrix[row][col-1]
                if course_name:
                    course = next(
                        (c for c in self.scheduler.selected_courses if c.name == course_name),
                        None
                    )
                    
                    if course:
                        item = QtWidgets.QTableWidgetItem(course.name)
                        item.setTextAlignment(QtCore.Qt.AlignCenter)
                        # 为课程设置字体
                        font = QtGui.QFont('楷体', 10)
                        item.setFont(font)
                        
                        # 设置背景色和文字颜色
                        item.setBackground(QtGui.QColor(course_colors.get(course.course_type, '#FFFFFF')))
                        item.setForeground(QtGui.QColor('#333333'))  # 深灰色文字
                        
                        tooltip = (
                            f"课程：{course.name}\n"
                            f"教师：{course.teacher}\n"
                            f"地点：{course.location}\n"
                            f"学分：{course.credit}\n"
                            f"类型：{course.course_type}"
                        )
                        item.setToolTip(tooltip)
                        
                        self.schedule_table.setItem(row, col, item)
        
        # 调整行高
        for i in range(self.schedule_table.rowCount()):
            self.schedule_table.setRowHeight(i, 40)
        
        # 设置表格整体样式
        self.schedule_table.setStyleSheet("""
            QTableWidget {
                background-color: white;
                gridline-color: #E0E0E0;
                border: 1px solid #BDBDBD;
                border-radius: 5px;
            }
            QTableWidget::item {
                border: 1px solid #E0E0E0;
                border-radius: 2px;
            }
            QTableWidget::item:selected {
                background-color: #E8EAF6;
            }
        """)

    def update_statistics(self, courses):
        """更新统计信息"""
        total_credits = sum(course.credit for course in courses)
        course_types = {}
        for course in courses:
            course_type = course.course_type
            course_types[course_type] = course_types.get(course_type, 0) + 1
        
        stats_text = (
            f"总课程数：{len(courses)}门\n"
            f"总学分：{total_credits}分\n"
            f"课程类型分布：\n"
        )
        for course_type, count in course_types.items():
            stats_text += f"  {course_type}: {count}门\n"
        
        self.stats_label.setText(stats_text)

    def update_course_list(self, courses):
        """更新课程列表"""
        course_list_text = "课程列表：\n\n"
        
        # 按类型分组课程
        course_by_type = {}
        for course in courses:
            course_type = course.course_type
            if course_type not in course_by_type:
                course_by_type[course_type] = []
            course_by_type[course_type].append(course)
        
        # 按类型显示课程
        for course_type, type_courses in course_by_type.items():
            course_list_text += f"【{course_type}】\n"
            for course in type_courses:
                course_list_text += (
                    f"• {course.name} ({course.credit}学分)\n"
                    f"  教师：{course.teacher}\n"
                    f"  时间：{course.time}\n"
                    f"  地点：{course.location}\n\n"
                )
        
        self.course_list.setText(course_list_text)

    def export_schedule(self):
        """导出课表"""
        try:
            # 生成HTML格式的课表
            html_content = self.generate_html_schedule()
            
            # 获取当前时间作为文件名
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"课表_{timestamp}.html"
            
            # 保存文件
            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
                self,
                "保存课表",
                filename,
                "HTML Files (*.html);;All Files (*)"
            )
            
            if file_path:
                # 确保文件路径有.html后缀
                if not file_path.lower().endswith('.html'):
                    file_path += '.html'
                
                # 使用UTF-8编码保存文件
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                QtWidgets.QMessageBox.information(
                    self,
                    "导出成功",
                    f"课表已成功导出到：\n{file_path}"
                )
        
        except Exception as e:
            import traceback
            error_msg = f"导出课表时出错：\n{str(e)}\n\n详细错误信息：\n{traceback.format_exc()}"
            print(error_msg)  # 打印详细错误信息到控制台
            QtWidgets.QMessageBox.warning(
                self,
                "导出失败",
                f"导出课表时出错：\n{str(e)}"
            )

    def generate_html_schedule(self):
        """生成HTML格式的课表"""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>课程表</title>
            <style>
                body { font-family: '楷体', sans-serif; }
                table { border-collapse: collapse; width: 100%; }
                th, td { border: 1px solid black; padding: 8px; text-align: center; }
                th { background-color: #f2f2f2; }
                .course-必修课 { background-color: #FFE4E1; }
                .course-选择性必修课 { background-color: #E0FFFF; }
                .course-通识课 { background-color: #F0FFF0; }
                .info { margin: 20px 0; }
                .header { text-align: center; margin: 20px 0; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>课程表</h1>
                <p>{student_info}</p>
            </div>
            <table>
                <tr>
                    <th>时间</th>
                    <th>周一</th>
                    <th>周二</th>
                    <th>周三</th>
                    <th>周四</th>
                    <th>周五</th>
                </tr>
                {table_content}
            </table>
            <div class="info">
                <h2>统计信息</h2>
                {stats_info}
            </div>
            <div class="info">
                <h2>课程列表</h2>
                {course_list}
            </div>
        </body>
        </html>
        """
        
        # 获取表格内容
        table_content = ""
        for row in range(self.schedule_table.rowCount()):
            table_content += "<tr>"
            for col in range(self.schedule_table.columnCount()):
                item = self.schedule_table.item(row, col)
                if item:
                    cell_content = item.text().replace('\n', '<br>')
                    cell_class = ""
                    if col > 0:  # 不是时间列
                        tooltip = item.toolTip()
                        if "类型：" in tooltip:
                            course_type = tooltip.split("类型：")[1].split("\n")[0]
                            cell_class = f' class="course-{course_type}"'
                    table_content += f"<td{cell_class}>{cell_content}</td>"
                else:
                    table_content += "<td></td>"
            table_content += "</tr>"
        
        # 生成完整的HTML
        html_content = html_template.format(
            student_info=self.student_info.text(),
            table_content=table_content,
            stats_info=self.stats_label.text().replace('\n', '<br>'),
            course_list=self.course_list.toPlainText().replace('\n', '<br>')
        )
        
        return html_content
