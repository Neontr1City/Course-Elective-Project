# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optimal.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QMessageBox
import os
import random
from config import UI_CONFIG
from extract_courses import extract_courses_by_grade_and_major, has_time_conflict

# 导入主程序的用户数据
try:
    from main_enhanced import user_data
except ImportError:
    user_data = {"compulsory_courses": [], "optional_compulsory_courses": []}

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(833, 748)
        
        # 应用统一样式
        Dialog.setStyleSheet(UI_CONFIG['component_styles']['dialog'])
        
        # 获取当前脚本所在目录
        base_dir = os.path.dirname(os.path.abspath(__file__))
        res_dir = os.path.join(base_dir, "res")
        
        # 标题按钮
        self.pushButton_2 = QtWidgets.QPushButton(Dialog)
        self.pushButton_2.setGeometry(QtCore.QRect(250, 50, 300, 80))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.setText("通识课选择")  # 直接设置标题文字
        self.pushButton_2.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #000000;
                border-radius: 15px;
                color: #000000;
                font-family: '楷体';
                font-size: 24px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #f0f0f0;
            }
        """)
        
        # 确认按钮
        self.confirm = QtWidgets.QPushButton(Dialog)
        self.confirm.setGeometry(QtCore.QRect(600, 690, 120, 35))
        self.confirm.setObjectName("confirm")
        self.confirm.setText("确认")  # 直接设置按钮文字
        self.confirm.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #000000;
                border-radius: 5px;
                padding: 8px 16px;
                font-family: '楷体';
                font-size: 16px;
                font-weight: bold;
                color: #000000;
            }
            QPushButton:hover {
                background-color: #f0f0f0;
            }
        """)
        
        # 返回按钮
        self.back = QtWidgets.QPushButton(Dialog)
        self.back.setGeometry(QtCore.QRect(30, 690, 120, 35))
        self.back.setObjectName("back")
        self.back.setText("返回")  # 直接设置按钮文字
        self.back.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #000000;
                border-radius: 5px;
                padding: 8px 16px;
                font-family: '楷体';
                font-size: 16px;
                font-weight: bold;
                color: #000000;
            }
            QPushButton:hover {
                background-color: #f0f0f0;
            }
        """)
        
        # 背景
        self.background = QtWidgets.QLabel(Dialog)
        self.background.setGeometry(QtCore.QRect(0, 0, 871, 751))
        self.background.setText("")
        if os.path.exists(os.path.join(res_dir, "背景.png")):
            self.background.setPixmap(QtGui.QPixmap(os.path.join(res_dir, "背景.png")))
        self.background.setObjectName("background")
        
        # 推荐信息显示区域
        self.textBrowser = QtWidgets.QTextBrowser(Dialog)
        self.textBrowser.setGeometry(QtCore.QRect(50, 170, 280, 400))
        self.textBrowser.setObjectName("textBrowser")
        self.textBrowser.setStyleSheet(UI_CONFIG['component_styles']['text_browser'])
        
        # 学分显示区域布局调整
        # 背景按钮
        self.pushButton_4 = QtWidgets.QPushButton(Dialog)
        self.pushButton_4.setGeometry(QtCore.QRect(280, 690, 280, 51))
        self.pushButton_4.setText("")
        self.pushButton_4.setObjectName("pushButton_4")
        self.pushButton_4.setStyleSheet(UI_CONFIG['component_styles']['credits_display']['background'])
        
        # 学分标签 - 调整为左对齐，为数字留出空间
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setGeometry(QtCore.QRect(290, 680, 100, 71))  # 减小宽度，只容纳文字
        self.label.setObjectName("label")
        self.label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)  # 左对齐，垂直居中
        self.label.setStyleSheet(UI_CONFIG['component_styles']['credits_display']['label'])
        
        # 学分显示 - 移到标签右侧
        self.all_points = QtWidgets.QLCDNumber(Dialog)
        self.all_points.setGeometry(QtCore.QRect(390, 690, 160, 51))  # 调整位置到标签右侧
        self.all_points.setObjectName("all_points")
        self.all_points.setStyleSheet(UI_CONFIG['component_styles']['credits_display']['lcd'])
        self.all_points.setDigitCount(4)  # 设置显示位数
        self.all_points.setSegmentStyle(QtWidgets.QLCDNumber.Flat)  # 设置显示风格
        
        # 学分显示背景
        self.credits_background = QtWidgets.QPushButton(Dialog)
        self.credits_background.setGeometry(QtCore.QRect(280, 680, 280, 71))
        self.credits_background.setObjectName("credits_background")
        self.credits_background.setStyleSheet(UI_CONFIG['component_styles']['credits_display']['background'])
        
        # 课程列表表格
        self.list = QtWidgets.QTableWidget(Dialog)
        self.list.setGeometry(QtCore.QRect(350, 170, 300, 400))
        self.list.setObjectName("list")
        self.list.setColumnCount(4)
        self.list.setStyleSheet(UI_CONFIG['component_styles']['table'])
        
        # 设置表头
        headers = ["课程名称", "学分", "时间", "推荐"]
        for i, header in enumerate(headers):
            item = QtWidgets.QTableWidgetItem()
            item.setText(header)
            self.list.setHorizontalHeaderItem(i, item)
        
        # 复选框区域 - 使用滚动区域
        self.checkbox_widget = QtWidgets.QWidget(Dialog)
        self.checkbox_widget.setGeometry(QtCore.QRect(670, 170, 150, 400))
        
        self.scroll_area = QtWidgets.QScrollArea(self.checkbox_widget)
        self.scroll_area.setGeometry(QtCore.QRect(0, 0, 150, 400))
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                border: 2px solid #000000;
                border-radius: 10px;
                background-color: #ffffff;
            }
        """)
        
        self.scroll_content = QtWidgets.QWidget()
        self.scroll_area.setWidget(self.scroll_content)
        
        self.checkbox_layout = QtWidgets.QVBoxLayout(self.scroll_content)
        self.checkbox_layout.setContentsMargins(10, 10, 10, 10)
        self.checkbox_layout.setSpacing(8)
        
        # 复选框列表将动态创建
        self.checkboxes = []
        
        # 设置z-order
        self.background.raise_()
        self.list.raise_()
        self.pushButton_4.raise_()
        self.pushButton_2.raise_()
        self.confirm.raise_()
        self.textBrowser.raise_()
        self.all_points.raise_()
        self.label.raise_()
        self.back.raise_()
        self.checkbox_widget.raise_()

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "通识课选择"))
        
        # 设置标题按钮文字
        self.pushButton_2.setText(_translate("Dialog", "通识课选择"))
        
        # 设置确认和返回按钮文字
        self.confirm.setText(_translate("Dialog", "确认"))
        self.back.setText(_translate("Dialog", "返回"))
        
        # 设置学分标签文字
        label_font = QtGui.QFont()
        label_font.setFamily("楷体")
        label_font.setPointSize(18)
        label_font.setBold(True)
        self.label.setFont(label_font)
        self.label.setText(_translate("Dialog", "已选学分"))

class OptimalDialog(QtWidgets.QDialog, Ui_Dialog):
    def __init__(self, grade, major, parent=None):
        super().__init__(parent)
        self.setupUi(self)
        self.grade = grade
        self.major = major
        self.courses = []
        self.selected_courses = []
        self.existing_courses = []  # 已选课程列表（用于时间冲突检查）
        
        # 获取已选择的必修课和选择性必修课
        self.load_existing_courses()
        
        # 连接信号
        self.confirm.clicked.connect(self.confirm_selection)
        self.back.clicked.connect(self.reject)
        
        # 加载课程并进行智能推荐
        self.load_courses()
        
        # 初始化显示已有学分
        self.update_selection()

    def load_existing_courses(self):
        """加载已选择的课程（用于时间冲突检查）"""
        try:
            # 从user_data获取已选课程
            self.existing_courses = []
            
            # 添加必修课
            for course in user_data.get("compulsory_courses", []):
                if course.get('time'):
                    self.existing_courses.append({
                        'name': course['name'],
                        'time': course['time'],
                        'type': '必修课'
                    })
            
            # 添加选择性必修课
            for course in user_data.get("optional_compulsory_courses", []):
                if course.get('time'):
                    self.existing_courses.append({
                        'name': course['name'],
                        'time': course['time'],
                        'type': '选择性必修课'
                    })
            
            print(f"已选课程数量: {len(self.existing_courses)}")
            
        except Exception as e:
            print(f"加载已选课程失败: {e}")
            self.existing_courses = []

    def load_courses(self):
        """加载通识课程并进行智能推荐"""
        try:
            # 生成示例通识课程数据（实际项目中应从数据库或文件读取）
            sample_courses = [
                {"课程名称": "大学英语", "学分": 2, "上课时间": "周一3-4节", "教师": "李教授", "类型": "语言类"},
                {"课程名称": "中国文学经典", "学分": 3, "上课时间": "周二1-2节", "教师": "王教授", "类型": "文学类"},
                {"课程名称": "世界历史概论", "学分": 2, "上课时间": "周三5-6节", "教师": "张教授", "类型": "历史类"},
                {"课程名称": "艺术欣赏", "学分": 2, "上课时间": "周四7-8节", "教师": "赵教授", "类型": "艺术类"},
                {"课程名称": "心理学导论", "学分": 3, "上课时间": "周五3-4节", "教师": "陈教授", "类型": "心理类"},
                {"课程名称": "环境科学概论", "学分": 2, "上课时间": "周一7-8节", "教师": "刘教授", "类型": "科学类"},
                {"课程名称": "经济学原理", "学分": 3, "上课时间": "周二5-6节", "教师": "孙教授", "类型": "经济类"},
                {"课程名称": "哲学思想史", "学分": 2, "上课时间": "周三1-2节", "教师": "周教授", "类型": "哲学类"},
                {"课程名称": "体育健康", "学分": 1, "上课时间": "周四3-4节", "教师": "吴教授", "类型": "体育类"},
                {"课程名称": "音乐欣赏", "学分": 2, "上课时间": "周五1-2节", "教师": "郑教授", "类型": "艺术类"},
                {"课程名称": "数学思维", "学分": 3, "上课时间": "周一1-2节", "教师": "马教授", "类型": "数学类"},
                {"课程名称": "社会学概论", "学分": 2, "上课时间": "周二7-8节", "教师": "冯教授", "类型": "社会类"},
            ]
            
            # 进行智能筛选，推荐时间不冲突的课程
            recommended_courses = self.smart_course_recommendation(sample_courses)
            
            self.courses = recommended_courses
            self.update_course_display()
            self.show_recommendation_info()
            
        except Exception as e:
            print(f"加载课程失败: {e}")
            self.courses = []

    def smart_course_recommendation(self, all_courses):
        """智能推荐时间不冲突的课程"""
        recommended = []
        conflict_courses = []
        
        for course in all_courses:
            course_time = course.get('上课时间', '')
            has_conflict = False
            
            # 检查与已选课程的时间冲突
            for existing in self.existing_courses:
                if self.check_time_conflict(course_time, existing['time']):
                    has_conflict = True
                    conflict_courses.append({
                        'course': course,
                        'conflict_with': existing['name'],
                        'conflict_type': existing['type']
                    })
                    break
            
            if not has_conflict:
                course['recommended'] = True
                recommended.append(course)
            else:
                course['recommended'] = False
                recommended.append(course)
        
        # 按推荐优先级排序（推荐的在前面）
        recommended.sort(key=lambda x: (not x['recommended'], x['课程名称']))
        
        return recommended

    def check_time_conflict(self, time1, time2):
        """检查两个时间是否冲突"""
        if not time1 or not time2:
            return False
        
        try:
            # 简单的时间冲突检查逻辑
            # 提取星期几和节次信息
            def parse_time(time_str):
                time_str = str(time_str).strip()
                if '周' in time_str and '节' in time_str:
                    # 提取星期
                    weekday = ''
                    if '周一' in time_str: weekday = '周一'
                    elif '周二' in time_str: weekday = '周二'
                    elif '周三' in time_str: weekday = '周三'
                    elif '周四' in time_str: weekday = '周四'
                    elif '周五' in time_str: weekday = '周五'
                    elif '周六' in time_str: weekday = '周六'
                    elif '周日' in time_str: weekday = '周日'
                    
                    # 提取节次
                    periods = []
                    if '1' in time_str: periods.append(1)
                    if '2' in time_str: periods.append(2)
                    if '3' in time_str: periods.append(3)
                    if '4' in time_str: periods.append(4)
                    if '5' in time_str: periods.append(5)
                    if '6' in time_str: periods.append(6)
                    if '7' in time_str: periods.append(7)
                    if '8' in time_str: periods.append(8)
                    
                    return weekday, set(periods)
                return '', set()
            
            weekday1, periods1 = parse_time(time1)
            weekday2, periods2 = parse_time(time2)
            
            # 如果是同一天且时间段有重叠，则冲突
            if weekday1 == weekday2 and weekday1 and periods1 & periods2:
                return True
            
            return False
            
        except Exception as e:
            print(f"时间冲突检查失败: {e}")
            return False

    def update_course_display(self):
        """更新课程显示"""
        if not self.courses:
            return
        
        # 清空现有复选框
        for checkbox in self.checkboxes:
            checkbox.deleteLater()
        self.checkboxes.clear()
        
        # 更新表格
        self.list.setRowCount(len(self.courses))
        
        for i, course in enumerate(self.courses):
            # 表格显示
            name_item = QtWidgets.QTableWidgetItem(course['课程名称'])
            credit_item = QtWidgets.QTableWidgetItem(str(course['学分']))
            time_item = QtWidgets.QTableWidgetItem(course.get('上课时间', ''))
            
            # 推荐状态
            if course.get('recommended', False):
                recommend_item = QtWidgets.QTableWidgetItem("推荐")
                recommend_item.setBackground(QtGui.QColor(144, 238, 144))  # 浅绿色
                name_item.setBackground(QtGui.QColor(144, 238, 144))
                credit_item.setBackground(QtGui.QColor(144, 238, 144))
                time_item.setBackground(QtGui.QColor(144, 238, 144))
            else:
                recommend_item = QtWidgets.QTableWidgetItem("冲突")
                recommend_item.setBackground(QtGui.QColor(255, 182, 193))  # 浅红色
                name_item.setBackground(QtGui.QColor(255, 182, 193))
                credit_item.setBackground(QtGui.QColor(255, 182, 193))
                time_item.setBackground(QtGui.QColor(255, 182, 193))
            
            self.list.setItem(i, 0, name_item)
            self.list.setItem(i, 1, credit_item)
            self.list.setItem(i, 2, time_item)
            self.list.setItem(i, 3, recommend_item)
            
            # 创建复选框
            checkbox = QtWidgets.QCheckBox(self.scroll_content)
            checkbox.setText(f"{course['课程名称']} ({course['学分']}分)")
            checkbox.setStyleSheet(UI_CONFIG['component_styles']['checkbox'])
            
            # 推荐课程用不同颜色显示，但不自动勾选
            if course.get('recommended', False):
                checkbox.setStyleSheet(UI_CONFIG['component_styles']['checkbox'] + """
                    QCheckBox {
                        font-weight: bold;
                        color: #4CAF50;
                    }
                """)
            
            checkbox.stateChanged.connect(self.update_selection)
            self.checkboxes.append(checkbox)
            self.checkbox_layout.addWidget(checkbox)
        
        # 调整表格列宽
        self.list.resizeColumnsToContents()
        
        # 更新学分显示
        self.update_selection()

    def show_recommendation_info(self):
        """显示推荐信息"""
        try:
            recommended_count = len([c for c in self.courses if c.get('recommended', False)])
            conflict_count = len(self.courses) - recommended_count
            
            info_html = f"""
            <h3 style='color: #2196F3; font-family: 楷体;'>📚 通识课推荐</h3>
            <p style='font-family: 楷体;'><strong>推荐策略：</strong>优先选择与已选课程时间不冲突的课程</p>
            <p style='font-family: 楷体;'><strong>推荐课程：</strong>{recommended_count} 门</p>
            <p style='font-family: 楷体;'><strong>时间冲突：</strong>{conflict_count} 门</p>
            
            <h4 style='color: #4CAF50; font-family: 楷体;'>✅ 推荐课程</h4>
            """
            
            for course in self.courses:
                if course.get('recommended', False):
                    info_html += f"""
                    <div style='margin: 5px 0; padding: 5px; background-color: #f0f8f0; border-radius: 3px; font-family: 楷体;'>
                        <strong>{course['课程名称']}</strong><br>
                        时间: {course.get('上课时间', '')}<br>
                        学分: {course['学分']}
                    </div>
                    """
            
            if conflict_count > 0:
                info_html += f"<h4 style='color: #f44336; font-family: 楷体;'>⚠️ 时间冲突课程</h4>"
                for course in self.courses:
                    if not course.get('recommended', False):
                        info_html += f"""
                        <div style='margin: 5px 0; padding: 5px; background-color: #fff0f0; border-radius: 3px; font-family: 楷体;'>
                            <strong>{course['课程名称']}</strong><br>
                            时间: {course.get('上课时间', '')}<br>
                            <span style='color: #f44336;'>与已选课程时间冲突</span>
                        </div>
                        """
            
            self.textBrowser.setHtml(info_html)
            
        except Exception as e:
            print(f"显示推荐信息失败: {e}")
            self.textBrowser.setHtml("<p style='font-family: 楷体;'>推荐信息加载失败</p>")

    def update_selection(self):
        """更新选择状态"""
        current_selection_credits = 0
        selected_count = 0
        
        for i, checkbox in enumerate(self.checkboxes):
            if checkbox.isChecked():
                current_selection_credits += self.courses[i]['学分']
                selected_count += 1
        
        # 获取已有的必修课和选择性必修课学分
        try:
            from main_enhanced import user_data
            existing_credits = user_data.get("total_credits", 0)
            total_display_credits = existing_credits + current_selection_credits
        except:
            total_display_credits = current_selection_credits
        
        # 显示累积学分
        self.all_points.display(total_display_credits)
        self.label.setText("累积学分")  # 简化标签文字，为数字留出更多空间

    def confirm_selection(self):
        """确认选择"""
        self.selected_courses = []
        
        for i, checkbox in enumerate(self.checkboxes):
            if checkbox.isChecked():
                course = self.courses[i].copy()
                self.selected_courses.append(course)
        
        if not self.selected_courses:
            QMessageBox.warning(self, "提示", "请至少选择一门通识课程！")
            return
        
        print(f"确认选择了{len(self.selected_courses)}门通识课程")
        for course in self.selected_courses:
            print(f"- {course['课程名称']} ({course['学分']}分)")
        
        # 保存通识课结果到全局数据并累积学分
        try:
            from main_enhanced import user_data
            
            formatted_general = []
            for course in self.selected_courses:
                formatted_general.append({
                    'name': course.get('课程名称', ''),
                    'credit': float(course.get('学分', 0)),
                    'time': course.get('上课时间', ''),
                    'location': course.get('上课地点', ''),
                    'teacher': course.get('教师', '')
                })
            
            # 保存到全局数据
            user_data["general_courses"] = formatted_general
            
            # 累积学分（加到已有的必修课和选择性必修课学分上）
            general_credits = sum(course['credit'] for course in formatted_general)
            user_data["total_credits"] += general_credits
            
            print(f"通识课完成，新增学分: {general_credits}")
            print(f"最终累积总学分: {user_data['total_credits']}")
            
            # 跳转到AI智能分析评估
            from evaluation import Ui_Dialog as EvaluationUi
            from PyQt5 import QtWidgets
            
            evaluation_dialog = QtWidgets.QDialog()
            evaluation_ui = EvaluationUi()
            evaluation_ui.setupUi(evaluation_dialog)
            
            # 创建评估对话框实例
            from main_enhanced import EvaluationDialog
            evaluation_instance = EvaluationDialog()
            
            # 关闭当前界面并显示AI分析界面
            self.accept()
            evaluation_instance.exec_()
            
        except Exception as e:
            print(f"保存通识课结果或跳转失败: {e}")
            self.accept()

    def get_selected_courses(self):
        """获取选中的课程"""
        return [
            {
                '课程名称': course['课程名称'],
                '学分': course['学分'],
                '上课时间': course.get('上课时间', ''),
                '上课地点': course.get('上课地点', ''),
                '教师': course.get('教师', ''),
                '类型': course.get('类型', '通识课')
            }
            for course in self.selected_courses
        ]
